# 前言
为什么要使用解构赋值，ES5及以前的版本
```javascript
var obj = {
    name:'li',
    age:18
};
var name = obj.name,
    age = obk.age;
```
虽然这段代码看上去也挺简单的,但想象一下如果你要给大量的变量赋值,你得一个一个的赋值。
或者你需要取一个嵌套结构数据的某个值,也许你得遍历整个结构。
如果你能把数据解构成一些小小的片段,那获取信息将会更加容易。

### 对象的解构
对象解构的语法形式是在一个赋值操作符左边放置一个对象字面量，例如：
```javascript
let obj = {
    name:'li',
    age:18
};
let {name,age} = obj;
console.log(name); //li
console.log(age); //18
````
### 非同名变量赋值
在上面的例子中，我们使用与对象属性名相同的变量名称，当然，我们也可以定义与属性不同的变量名称。
```javascript 
let obj = {
    name:'li',
    age:18
};
let {name:name:fullname,age:year} = obj;
console.log(fullname); //li
console.log(year); //18
```
在这里，我们创建了两个局部变量，fullname和yaer，并将它们映射到了name和age。

### 默认值
使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为 undefined，就像这样：
```javasctipt 
let obj = {
    name:'li',
    age:18
};
let {country} = obj;
console.log(country); //undefined
```
上面的代码中，额外定义了一个局部变量country，然后尝试为它赋值，然而在obj对象上，没有对应的属性名称和属性值，所有被自动定义为undefined。

我们可以自己定义一个默认值，在属性名称后添加一个(=)和相对应的默认值即可。
```javasctipt 
let obj = {
    name:'li',
    age:18
};
let {name,age,country = 'China'} = obj;
console.log(country); //China
```
并且不会改变obj
```javascript 
console.log(obj.country); //undefined;
```
只有对象 obj 上没有该属性或者属性值为 undefined 时该默认值才生效。
```javasctipt 
let obj = {
    name:'li',
    age:18
};
let {name = 'wang'} = obj;
console.log(name); //li
```